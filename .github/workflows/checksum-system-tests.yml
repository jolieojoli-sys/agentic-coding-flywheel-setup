name: Checksum System E2E Tests

on:
  push:
    branches: [main]
    paths:
      - '.github/workflows/checksum-*.yml'
      - 'scripts/lib/security.sh'
      - 'checksums.yaml'
      - 'scripts/lib/test_security.sh'
  pull_request:
    branches: [main]
    paths:
      - '.github/workflows/checksum-*.yml'
      - 'scripts/lib/security.sh'
      - 'checksums.yaml'
      - 'scripts/lib/test_security.sh'

jobs:
  # ============================================================
  # YAML Syntax Validation
  # Catches issues like template literal indentation breaking YAML
  # ============================================================
  yaml-lint:
    name: Validate Workflow YAML Syntax
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install yamllint
        run: pip install yamllint

      - name: Create yamllint config
        run: |
          cat > .yamllint.yml << 'EOF'
          extends: default
          rules:
            # Allow long lines in workflows (common for shell scripts)
            line-length:
              max: 200
            # Allow both key styles
            key-ordering: disable
            # Be lenient with comments
            comments:
              min-spaces-from-content: 1
            # Allow document start/end flexibility
            document-start: disable
            document-end: disable
            # Ensure proper indentation (catches template literal bugs)
            indentation:
              spaces: 2
              indent-sequences: whatever
            # Truthy values as strings are common in workflows
            truthy:
              allowed-values: ['true', 'false', 'on', 'off']
          EOF

      - name: Lint all workflow YAML files
        run: |
          echo "Validating YAML syntax for all workflow files..."
          yamllint -c .yamllint.yml .github/workflows/*.yml
          echo "âœ… All workflow YAML files have valid syntax"

  # ============================================================
  # Security.sh Unit Tests
  # Tests the core checksum verification functions
  # ============================================================
  security-unit-tests:
    name: Security.sh Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run security unit tests
        run: bash scripts/lib/test_security.sh

  # ============================================================
  # Checksum Verification E2E Test
  # Ensures verify command produces valid JSON
  # ============================================================
  checksum-verification-e2e:
    name: Checksum Verification E2E
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Make security.sh executable
        run: chmod +x ./scripts/lib/security.sh

      - name: Test --verify --json output format
        run: |
          echo "Testing JSON output format..."

          # Run verification and capture output (stderr separate to avoid corrupting JSON)
          ./scripts/lib/security.sh --verify --json > result.json 2>verify-errors.log || true

          # Validate JSON structure
          if ! jq empty result.json 2>/dev/null; then
            echo "âŒ FAIL: Output is not valid JSON"
            echo "Output was:"
            cat result.json
            exit 1
          fi

          echo "âœ… Output is valid JSON"

          # Check required fields exist
          for field in timestamp total matches mismatches errors; do
            if ! jq -e ".$field" result.json >/dev/null 2>&1; then
              echo "âŒ FAIL: Missing required field: $field"
              exit 1
            fi
            echo "âœ… Field exists: $field"
          done

          echo ""
          echo "JSON structure validated successfully"

      - name: Test checksum counts are reasonable
        run: |
          echo "Validating checksum counts..."

          ./scripts/lib/security.sh --verify --json > result.json 2>/dev/null || true

          total=$(jq '.total' result.json)
          matches=$(jq '.matches | length' result.json)
          mismatches=$(jq '.mismatches | length' result.json)
          errors=$(jq '.errors | length' result.json)

          echo "Total: $total"
          echo "Matches: $matches"
          echo "Mismatches: $mismatches"
          echo "Errors: $errors"

          # Should have at least 10 known installers
          if [[ $total -lt 10 ]]; then
            echo "âŒ FAIL: Expected at least 10 installers, got $total"
            exit 1
          fi
          echo "âœ… Have $total installers (expected >= 10)"

          # Counts should add up
          counted=$((matches + mismatches + errors))
          if [[ $counted -gt $total ]]; then
            echo "âŒ FAIL: Counts don't add up (matches + mismatches + errors = $counted > total = $total)"
            exit 1
          fi
          echo "âœ… Counts are consistent"

      - name: Test --update-checksums produces valid YAML
        run: |
          echo "Testing --update-checksums output..."

          # Generate new checksums (sample, not full - takes too long)
          # Note: stderr is separate to avoid corrupting YAML with progress messages
          timeout 60 ./scripts/lib/security.sh --update-checksums > new-checksums.yaml 2>update-progress.log || {
            # Timeout is OK for partial test
            echo "Partial checksums generated (timeout after 60s is expected)"
          }

          # Check YAML structure
          if ! head -20 new-checksums.yaml | grep -q "installers:"; then
            echo "âŒ FAIL: Missing 'installers:' key in output"
            cat new-checksums.yaml
            exit 1
          fi
          echo "âœ… Output contains 'installers:' key"

          # Check YAML has valid structure (basic validation without PyYAML dependency)
          # Look for expected keys in the output
          if head -50 new-checksums.yaml | grep -qE "^  [a-z_]+:$"; then
            echo "âœ… YAML has expected structure (installer entries found)"
          else
            echo "âš ï¸ Warning: YAML structure may be incomplete (expected for partial generation with 60s timeout)"
          fi

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: checksum-e2e-results
          path: |
            result.json
            new-checksums.yaml
            verify-errors.log
            update-progress.log

  # ============================================================
  # Checksum Monitor Workflow Dry Run
  # Simulates what the monitor does without committing
  # ============================================================
  checksum-monitor-dry-run:
    name: Checksum Monitor Logic Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: chmod +x ./scripts/lib/security.sh

      - name: Simulate verification step (as checksum-monitor does)
        id: verify
        run: |
          echo "ðŸ” Simulating checksum-monitor verification..."

          # This mirrors the logic in checksum-monitor.yml
          # Note: stderr separate to avoid corrupting JSON
          ./scripts/lib/security.sh --verify --json > current.json 2>/dev/null || true

          # Check if JSON is valid
          if ! jq empty current.json 2>/dev/null; then
            echo "error=invalid_json" >> $GITHUB_OUTPUT
            echo "âŒ Failed to parse verification output"
            cat current.json
            exit 1
          fi

          # Extract counts from JSON
          mismatches=$(jq '.mismatches | length' current.json)
          errors=$(jq '.errors | length' current.json)
          total_issues=$((mismatches + errors))

          echo "mismatches=$mismatches" >> $GITHUB_OUTPUT
          echo "errors=$errors" >> $GITHUB_OUTPUT
          echo "total_issues=$total_issues" >> $GITHUB_OUTPUT

          # Categorize changed tools (if any)
          TRUSTED_CHANGED=""
          EXTERNAL_CHANGED=""

          if [[ "$mismatches" -gt 0 ]]; then
            while IFS= read -r name; do
              url=$(jq -r --arg n "$name" '.mismatches[] | select(.name==$n) | .url // empty' current.json)
              if [[ "$url" == *"Dicklesworthstone"* ]]; then
                TRUSTED_CHANGED="${TRUSTED_CHANGED}${name},"
              else
                EXTERNAL_CHANGED="${EXTERNAL_CHANGED}${name},"
              fi
            done < <(jq -r '.mismatches[].name' current.json)
          fi

          # Remove trailing commas
          TRUSTED_CHANGED="${TRUSTED_CHANGED%,}"
          EXTERNAL_CHANGED="${EXTERNAL_CHANGED%,}"

          echo "trusted_changed=$TRUSTED_CHANGED" >> $GITHUB_OUTPUT
          echo "external_changed=$EXTERNAL_CHANGED" >> $GITHUB_OUTPUT

          if [[ "$total_issues" -gt 0 ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo ""
            echo "ðŸ“‹ Would update checksums for:"
            jq -r '.mismatches[] | "  - \(.name)"' current.json 2>/dev/null || true
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "âœ… All checksums match - no update needed"
          fi

      - name: Validate output parsing worked
        run: |
          echo "Verifying step outputs are set correctly..."

          # The step should have set these outputs
          echo "mismatches=${{ steps.verify.outputs.mismatches }}"
          echo "errors=${{ steps.verify.outputs.errors }}"
          echo "changed=${{ steps.verify.outputs.changed }}"
          echo "trusted_changed=${{ steps.verify.outputs.trusted_changed }}"
          echo "external_changed=${{ steps.verify.outputs.external_changed }}"

          # Mismatches should be a number
          if ! [[ "${{ steps.verify.outputs.mismatches }}" =~ ^[0-9]+$ ]]; then
            echo "âŒ FAIL: mismatches is not a number"
            exit 1
          fi
          echo "âœ… mismatches is a valid number"

          # Changed should be true or false
          if [[ "${{ steps.verify.outputs.changed }}" != "true" && "${{ steps.verify.outputs.changed }}" != "false" ]]; then
            echo "âŒ FAIL: changed is not true/false"
            exit 1
          fi
          echo "âœ… changed is a valid boolean"

      - name: Test would-generate valid checksums.yaml
        if: steps.verify.outputs.changed == 'true'
        run: |
          echo "Testing checksums generation..."

          # Run update (but don't actually use it)
          # stderr separate to avoid corrupting YAML with progress messages
          ./scripts/lib/security.sh --update-checksums > checksums.yaml.new 2>/dev/null || {
            echo "âš ï¸ Checksum generation may have timed out (expected for full run)"
          }

          if [[ -s checksums.yaml.new ]]; then
            echo "âœ… Generated non-empty checksums file"
          fi

      - name: Upload dry run results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: monitor-dry-run
          path: current.json

  # ============================================================
  # Integration Test: checksums.yaml matches current state
  # ============================================================
  checksum-freshness:
    name: Checksums Freshness Check
    runs-on: ubuntu-latest
    # This job verifies that committed checksums match upstream
    # It's expected to fail if upstream changed - that's the point of checksum-monitor
    continue-on-error: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check if checksums are up to date
        run: |
          chmod +x ./scripts/lib/security.sh

          echo "Checking if committed checksums match upstream..."

          if ./scripts/lib/security.sh --verify --json > result.json 2>/dev/null; then
            echo "âœ… All checksums are fresh"
          else
            echo "âš ï¸ Some checksums are stale (this triggers checksum-monitor)"
            echo ""
            jq -r '.mismatches[] | "  - \(.name)"' result.json 2>/dev/null || true
          fi
